# 4.2 견고성 vs 실패

오류가 발생할때 다음 중 하나를 선택해야 한다.

1. 더 높은 코드 계층이 오류를 처리 OR 전체 프로그램의 작동 중지
1. 오류를 처리하고 계속 진행

2번이 견고한 코드라 볼 수 있으나, 오류가 감지되지 않음, 사이드 이펙트의 시작점 일수도?

견고성보다는 실패가 많은 경우에 최선이다. (이어서 설명...)

## 4.2.1 신속하게 실패하라

신속하게 실패하기는 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것

* 복구 할 수 있는 오류의 경우 : 호출하는 쪽에서 오류를 복구할 기회 제공
* 복수할 수 없는 경우 : 개발자가 신속하게 해결할 기회 제공

코드가 신속하게 실패하지 않을 경우 발생할 수 있는 상황

바로 실패나 오류를 보여주지 않으면 문제가 발생 할 때 디버그 하기 어렵다.

손상된 데이터가 DB에 발견되고 몇달 후에 발견된다면? 영구히 파괴된 데이터! (마이그레이션..)

## 4.2.2 요란하게 실패하라

* 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막기 위한 것
* 예외를 발생해 프로그램이 중단되게 하자
* 오류메시지를 기록하는 법도 있지만?
  * 의식적인 로그 모니터링 노력이 필요함
  * 로그에 방해되는 다른 메시지가 많으면 묻힘
* 코드가 실패할때 신속하고, 요란한 오류를 낸다면?
  * 개발/테스트 중에 버그가 발견되는 이점
  * 배포 후 오류 보고로 버그 위치를 정확히 알게 되는 이점

## 4.2.3 복구 가능성의 범위

* 개별 요청 처리 도중, 버그가 있는 코드 경로를 실행하는 경우
  * 요청범위 내에선 복구 불가함
  * 서버 전체적으로는 복구 가능 (시스템 중단 방지)
* 일반적으로 견고하게 작성하는게 좋다.
  * 한번의 잘못된 요청으로 서비스 중지 X
  * 그러나 오류를 알아차리지 못한 채 계속 정상작동은 X -> 요란한 실패 필요
* 오류가 발견되면 오류를 기록하고 모니터링 하자.
  * 오류 정보 기록, 디버그, 알림 메시지

## 4.2.4 오류를 숨기지 않음

* 호출하는 쪽에서 복구하고자 할 수도 있는 오류를 숨기면, 복구할 기회 없어짐
* 복구할 수 없는 오류를 숨기면, 프로그래밍 오류가 감춰져 버그 수정 어려움
* 오류를 감추면 모든 것이 잘 작동하고 있다고 가정 -> 실제 코드는 제대로 동작 X -> 데이터 손상, 잘못된 정보 출력

> 오류가 나도 200을 리턴하는 참조모델 코드가 생각난다..

(아래) 오류 신호를 보내지 않는 예

### 기본값 반환

* (예제 4.3) 계좌 잔액을 조회하는 코드, 오류발생시 기본값 0을 반환, 오류여부 구별 불가
  * 잔액이 천만원인 사람이 0원으로 뜨면 기겁함
  * 이건 0원이 아니라 "죄송합니다. 서버 오류입니다." 에러메세지를 보여 줬어야 함.

### 널 객체 패턴

* 기본값을 의미하는 객체
* 빈 리스트 반환부터, 전체 클래스를 구현하는 방법이 있음
* (예제 4.4) result 에 대한 질의가 실패하면 빈 리스트 반환
  * 버그로 이어지기 쉬운 방법, 사용자는 미결제액 목록이 없다고 생각하게됨, 오류를 내는게 좋다.

### 아무것도 하지 않음

* (예제 4.5) 통화가 다르면 에러가 나는게 아니라 return 반환 시킴
  * 에러가 없으니 호출하는 쪽 에서는 this.items 리스트에 추가 되었다고 생각 -> 버그 발생

(아래) 다른 코드가 전달하는 오류를 억제하는 예

### 예외 억제

* (예제 4.6) 이메일 전송할때 오류가 발생하면 EmailExceiption
* catch 에서 아무동작 하지 않음 (탐지 불가) -> 로그를 심는것으로 개선하라

오류를 숨기는것은 수많은 미지급 송장과, 재정적으로 불건전한 데이터를 가지게 된다.