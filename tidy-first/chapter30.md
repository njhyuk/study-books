# 챕터 30 : 콘스탄틴의 등가성

* 필자는 소프트웨어 개발비용의 70%가 유지보수로 들어간 경험이 있다.
* 소프트웨어는 영원히 구동하는 기계처럼 한번 만들고 영원히 변함 없는걸로 생각하지만
  * 실제로는 정반대, 시스템의 미래 가치는 어제 추측이 아닌 오늘의 현실에서 드러남
* 결합도의 중요성
  * 소프트웨어 설계의 목표는 소프트웨어의 비용을 최소화 하는것
* 콘스탄틴의 등가성
  * 소프트웨어 비용은 그것을 변경하는 데 드는 비용과 거의 같다.
  * 소프트웨어 비용 ~= 변경 비용 
 
## 소프트웨어 수명 주기에 따른 누적 비용
* 로그 함수 곡선
  * 출시 전 기간은 작은 부분,총 비용 중에서도 작은 부분
  * 시스템 동작을 조금씩 변경하는 비용을 모두 합치면 출시 비용과 비슷해진다.
* 어느 날 표먼적으로는 이전의 모든 변경 사항과 유사한 변경 사항을 적용 했을 뿐인데
  * 이번 것은 우리 눈앞에서 폭발하고 만다. (열배, 백배, 천배로 비용 증가)

## 출시후 비용 증가가 가파른 이유

* 기존 시스템과의 마찰도 함께 일어나기 때문
  * 이전 버전과의 호환성
  * 운영 서버의 안정성
  * 아무 관련 없는 기능이 손상될 가능성

## 멱법칙 분포

* 소수의 큰 이상값을 발생시키는 일이 매우 중요하다
* 그것들을 합치면 훨씬 더 많은 정상 사건보다 더 큰 영향을 미친다
* 가장 큰 다섯 폭풍이 작은 폭풍 만개보다 더 큰 피해를 입힌다
  * 가장 비용이 많이 드는 하나의 변경이 나머지 변경을 모두 합친 것 보다 훨씬더 많은 비용이 든다
  * 변경 비용은 큰 변경들의 비용과 거의 같다
  
## 결론 

* 큰 변경들의 비용이 비싼 이유
  * 이 요소를 변경하려 했더니, 두 요소 변경, 각각 마다 또 다른 요소 변경..
  * 결합도가 변경을 전파한다.
* 소프트웨어 비용은 결합도와 거의 같다.
* 소프트웨어 비용을 줄이려면 결합도를 줄여야 한다.
