# 인덱스와 인덱싱

* 최적화는 MySQL 측면에서 하드웨어를 효율적으로 활용하게 해주는 다양한 기술과 알고리즘, 데이터 구조를 의미함
* 인덱스 없는 MySQL 성능
  * 작은 규모의 데이터만 들어올릴 수 있는 성능으로 제한됨
* 인덱스를 사용한 MySQL 성능
  * 대량의 데이터도 월등히 처리 가능

## 2-1 성능 향상과 관련 없는 딴짓

* 더 좋고 빠른 하드웨어, 스케일업부터 시작하지 마라
* 합리적인 두가지 예외 상황
  * 하드웨어 성능 부족으로 명백하게 느린 상황
    * 500GB의 데이터에 1GB의 메모리를 사용하는 경우 ->  32GB나 64GB로 늘려야 함
  * 애플리케이션 사용량이 급증, 안정성을 담보하기 위한 임시 방편인 상황
* 이러한 예외 상황이 아니면 최후의 선택, 아무것도 배우지 못함
  * 클라우드 환경에선 쉬운 하드웨어 교체가 매력적으로 다가옴

### MYSQL 튜닝

* 튜닝
  * 튜닝은 R&D이기에 일반적으로 적용할 수 있는 결과는 아닐것
  * 시스템 변수를 조정하는 행위, 구체적인 목표와 기준이 있는 실험실 수준의 작업
* 구성
  * 시스템 변수를 하드웨어와 환경에 적합한 값으로 설정하는 행위
* 최적화
  * 워크로드를 줄이거나 효율성을 높여 MYSQL 성능을 향상시키는 행위
  * 기존 하드웨어로 더 빠른 시간과 더 많은 용량 제공이 목표

튜닝은 레드헤링, 구성은 MySQL 8.0에서 자동으로 이루어짐, 우리는 최적화만 수행하면 됨

## 2-2 MySQL 인덱스: 시각적 소개

### InnoDB 테이블은 인덱스다

![img_1.png](img_1.png)

* 프라이머리키 id 열과, 세컨더리 인덱스 idx_a_b 가 있다
* a,b,c 열은 각 열의 이름으로 시작하는 원자 기호이다

B-트리 인덱스를 간단히 보여주면 다음과 같다

![img_2.png](img_2.png)

* 리프노드에 있는 4개의 인덱스 레코드 행은 처음 4개 행에 해당한다
* 프라이머리 키의 열값은 각 인덱스 레코드의 맨 위에 표시된다
* 다음 두가지만 중요하다
  * 프라이머리 키 조회는 매우 빠르고 효율적이다
  * 프라이머리 키는 MySQL 성능에서 핵심적인 역할을 한다

* 세컨더리 인덱스 idx_a_b
  * 리프노드는 프라이머리 키 값을 저장한다
  * 세컨더리 인덱스를 하용하면 전체 행을 읽기 위해 PK를 이용하여, 두번쨰 조회를 실행한다
* `select * from elem where a='AU' AND b='Be'` 쿼리 예시는 다음과 같다

![img_4.png](img_4.png)

1. 루트 노드에서 시작 "Au, Be" 에 대해 오른쪽으로 분기
2. 내부 노드에서 "Au, Be" 값에 대한 리프노드에서 오른쪽으로 분기
3. 프라이머리 키값 2를 얻음
4. 프라이머리키로 루트노드 검색.. 이후 비슷한 과정

MySQL의 세계에서 모든것은 프라이머리 키를 중심으로 돌아간다.

### 테이블 접근 방법

* 인덱스를 사용하여 행을 조회하는 방법은? 3가지 테이블 접근 방법중 하나
* 쿼리에 따라 인덱스 조회가 불가할 떄가 있다
  * 이떄는 인덱스 스캔, 테이블 스캔을 해야함 (단, 피해야함)

### 인덱스 조회

* 인덱스의 정렬된 구조와 접근 알고리즘 활용, 특정 행이나 행 범위를 찾는다
* 가장 빠르면서 효과적인 방법, 직접 쿼리 최적화의 본질
* 성능을 발휘하려면 모든 쿼리에서 인덱스 조회를 사용해야함

### 인덱스 스캔

* 인덱스 스캔이란? 인덱스 조회가 불가능할 때, 모든 행을 읽고 일치하지 않는 행을 필터링한다.
* 인덱스 스캔의 첫번째 유형은? 풀 인덱스 스캔
  * 인덱스 순서대로 모든 행을 읽는다
  * elem은 세컨더리 인덱스를 스캔하고 행을 순서대로 가져오는것보다, 풀 인덱스 스캔이 더 빠르다
    * `SELECT * from elem force index (a) order by a,b`
    * elem 은테이블이 작아서 프라이머리 키를 스캔하고 행을 정렬하는게 효율적이라서 그렇다

![img_5.png](img_5.png)

* 순서
  * SI (세컨더리 인덱스)의 첫번째값 Ag,B 읽기
  * PK에서 해당 행 찾기
  * SI의 두번째값 Al, Br 읽기
  * PK에서 해당 행 찾기
  * SI의 세번째값 Ar, Br 읽기
  * PK에서 해당 행 찾기
  * SI의 네번째값 Au, Be 읽기
  * PK에서 해당 행 찾기
* 세부사항
  * 세컨더리 인덱스를 순서대로 스캔하는 것은 순차 읽기
  * 프라이머리 키 조회는 거의 무작위 읽기

* 인덱스 스캔의 두번째 유형은? 인덱스 전용 스캔 (indexed-only scan)
  * 인덱스에서 열값을 읽기위해 커버링 인덱스가 필요함 (2-2절에서 다룸)
  * 세컨더리 인덱스에서 열값만 읽기에 커버링 인덱스가 필요함
* 풀테이블 스캔이 아닌 이상 인덱스 스캔으로 최적화 하지 마세요

### 테이블 스캔

* 프라이머리 키 순서대로 모든 행을 읽음, 인덱스 조회나 스캔을 수행할 수 없을때 유일한 옵션
* 테이블 스캔이 유리한 경우
  * 테이블이 작고 접근 빈도가 낮을 때
  * 테이블 선택도가 매우 낮을 때
* 일반적으로 성능에 굉장히 나쁨

### 맨 왼쪽 접두사 요구사항

다음은 맨왼쪽 접두사 (a), (a,b), (a,b,c) 각각을 사용한 where 절 예시

![img.png](img.png)

* 인덱스의 열 전체를 사용하는것이 이상적, 필수는 아님
* 인덱스를 사용하려면 쿼리가 인덱스의 맨 왼쪽 접두사를 사용해야 함

### EXPAIN: 쿼리 실행 계획

EXPAIN 명령어는 Mysql이 쿼리를 실행하는 방법을 설명함

![img_6.png](img_6.png)

* table
  * 테이블 이름, 참조된 서브쿼리 (Mysql이 결정한 조인 순서)
* type
  * ALL : 풀 테이블 스캔 
  * index : 인덱스 스캔
  * const, ref, range : 인덱스 조회의 접근 유형
* possible_keys
  * Mysql이 사용할 수 있는 인덱스 나열
* key
  * Mysql이 사용할 인덱스의 이름
* ref
  * 사용되는 값의 소스 나열
    * const -> a = 'Au' 는 하나의 값과 같은 상수 조건
  * 조인 순서상 이전 테이블의 열 참조
    * ref 열값과 일치하는 행을 찾음
* rows
  * 일치하는 행을 찾기 위해 조회할 예상 행의 수 추정
* Extra
  * 쿼리 실행 계획에 대한 부가 정보

### WHERE

![img_7.png](img_7.png)

* key: PRIMARY
  * 인덱스조회로 프라이머리 키를 사용할것임
* posible_keys : PRIMARY
  * 세컨더리 인덱스는 Mysql이 이 쿼리에서 사용할 수 없어서 나열되지 않음
* type: const
  * 모든 인덱스 열에 상수조건이 있을때 발생, 결과는 상수 행, 매우빠름
* Extra: NULL
  * 행과 일치할 필요가 없음을 의미?
    * 상수 행은 오직 하나의 행과만 일치할 수 있어서 그렇다
  * where id > 3 이라면 Extra: Using where 가 나옴
    * 일반적, where 조건으로 일치하는 행을 찾는다 
    * 접근 유형은 범위 스캔 (type: range) 이 됨
      * 즉 인덱스를 사용하여 값 범위 사이의 행을 읽음
      
![img_9.png](img_9.png)
![img_10.png](img_10.png)

* 예제 2-5 쿼리에 idx_a_b 조건이 맨 왼쪽 접두사에 대한 요구사항을 충족함
* 첫번째 쿼리는 a 열만 사용, 두번째 열은 a,b 사용
* const 접근 유형은 불가함
  * idx_a_b 가 비고유라 하나 이상의 행과 일치할 수 있음

![img_8.png](img_8.png)

인덱스 조회와 인덱싱되지 않은 열에 대한 EXPAIN 결과는 다음과 같음

![img_11.png](img_11.png)
![img_12.png](img_12.png)

* 인덱스를 사용하여 a 열의 조건에 대한 행을 조회하고 읽은 다음, c열의 조건과 일치하는 행을 찾음
* where 절에 일치하는건 없는데 rows 3의 의미
  * a열에 대한 인덱스 조회의 경우 참인 3개의 행을 찾았지만 c에 대해 일치하는게 없어서 그렇다

맨 왼쪽 접두사가 충족되지 않은 경우는?

![img_13.png](img_13.png)
![img_14.png](img_14.png)

* 인덱스 수행 불가 possible_keys: NULL, key:NULL
* type: ALL 테이블 풀스캔
* rows: 10 전체 행 수
* 최악의 쿼리 예시이다~

### Group By

* 값이 인덱스 순서에 따라 암묵적으로 그룹화됨
* Group By 를 최적화 하기 위해 인덱스를 사용할 수 있음
* idx_a_b 에 대해 a열은 다음과 같이 5개의 개별 그룹을 가짐

![img_15.png](img_15.png)

group by a에 대한 explain 계획

![img_16.png](img_16.png)

* `key: idx_a_b`
  * 인덱스를 사용하여 그룹화
* `Extra: Using index`
  * a열의 값만 읽음, 프라이머리 키에서 젠체 행을 읽지 않음
* `type: index`
  * 인덱스 스캔을 나타냄, 인덱스를 사용하지만 인덱스 조회는 아님
* `rows: 10`
  * where 절이 없어서 Mysql 이 모든 행을 읽음

a 열에 where 절을 추가하면?

![img_17.png](img_17.png)

* `Extra: Using where`
  * WHERE a != 'Ar' 을 나타냄
* `type: range`
  * != 연산자로 인해 범위 접근 유형으로 바뀜
  * 이해를 돕기위한 아래 그림 참조
  * ![img_18.png](img_18.png)
* Where 절에 b 조건만 있어도 멘 왼쪽 접두사 요구사항이 충족된다.
  * 아래 그림 참조
  * ![img_19.png](img_19.png)

맨 왼쪽 접두사가 없는 Group By는?

![img_20.png](img_20.png)

* 쿼리가 a 열에 조건이 없어도 인덱스를 사용한다?
  * Mysql 이 a 열의 인덱스를 스캔하고 있어서 맨 왼쪽 접두사가 충족됨
* group by c는 안됨
  * 인덱스에 b 열 값은 있지만 c 열 값은 없음
* Extra: Using temporary
  * 왼쪽 접두사 세트를 가지지 않아서 그렇다
  * 인덱스에서 a 열 값을 읽을때, 임시테이블 에서 b 열 값을 수집함
  * a열 값을 모두 읽은 후에는 count(*)에 의해 그룹화되고 집계된 임시 테이블에 대해 테이블 스캔

### Order By

* Mysql 은 Order By 절을 최적화하기 위해 정렬된 인덱스를 사용할 수 있음
  * 순서대로 행에 접근하기에 시간이 조금 더 걸리는 행 정렬을 피할 수 있음
* Mysql은 행정렬에는 Extra 필드에 Using filesort 를 출력함
  * 파일 정렬은 느리다는 평판이 있으나 빠름, 행정렬이 느린 응답의 근본 원인은 대체로 아님
* Order by 를 최적화 하는 첫번째 방법, 맨 왼쪽 접두사 사용
* 최적화 두번째 방법, 인덱스 상수로 맨 왼쪽 유지, 다음에 인덱스 열을 기준으로 정렬
  * ![img_21.png](img_21.png)
  * WHERE 조건 a 열이 상수라서 인덱스 (a,b) 사용 가능
  * 인덱스에서 a = 'Ar' 로 이동
    * 거기에서 b열값을 순서대로 읽는다
* 최적화 세번째 방법
  * 세컨더리 인덱스에 추가된 프라이머리 키로 Order By 하기
  * ![img_22.png](img_22.png)
  * 모든 세컨더리 인덱스의 끝에는 PK가 숨겨져 있기 때문
  * 위 WHERE 조건에 b를 제거하면?
    * ![img_23.png](img_23.png)
    * Using filesort 가 출력됨
      * 세컨더리 인덱스에 더이상 맨 왼쪽 접두사가 없어서 숨겨진 PK 사용 불가
    * ![img_24.png](img_24.png)
    * Using index condition 은 무엇일까?
      * 인덱스 컨디션 푸시 다운임
        * InnoDB 가 a='Al' 조건과 일치하는 행을 찾기 위해 idx_a_b 인덱스를 사용한다는 뜻
        * Mysql 이 자동으로 사용하기에 최적화 하지 않아도 된다
* filesort 는 정말 느릴까?
  * 백만행이 있는 테이블에 아래 쿼리를 실행 
  * ![img_25.png](img_25.png)
  * 둘쨰줄에서 ... 의 차이가 8, 즉 파일정렬에 8ms 만 소요
  * 왜 파일 정렬이 느리다는 평판이 있을까?
    * sort_buffer_size 를 초과할떄 디스크의 임시 파일을 사용함
    * HDD 는 메모리보다 수십 배 느림
    * 그러나 오늘날에는 SSD가 표준임, 매우 빠름

### 커버링 인덱스

![img_26.png](img_26.png)

* a와 b열의 WHERE 조건은 해당 인덱스 열을 가리킴
* SELECT 절의 해당 열을 다시 가리키기도 하여 인덱스에서 이러한 열값을 읽었음을 나타냄
* 일반적으로 Mysql 은 PK에서 전체 행을 읽어버림
  * 그러나 커버링 인덱스를 사용하면 MYsql 은 인덱스에서 열값만 읽을 수 있음

### 테이블 조인

* MySQL은 테이블 조인에 인덱스를 사용함
* 조인에 사용할 두번째 테이블 생성

![img_27.png](img_27.png)

* 인덱스가 하나 있음, PK 는 symbol 열
* elem 테이블의 a,b,c 열 값과 일치함
* 조인 시각화 예시는 다음과 같다

![img_28.png](img_28.png)

* Mysql 은 a in(...) 조건에 인덱스를 사용함
* 조인 테이블에 대한 인덱스 사용의 경우 두가지 사소한 차이가 있음
  * where 절은 join..ON 절을 재적성한 것
  * symbol 열의 조건값은 elem 에서 가져옴
* explain 은 다음과 같다

![img_29.png](img_29.png)

조인의 경우 두번째 테이블에 2개의 새로운 세부 정보가 있다.

* type : eq_ref
  * PK 나 유니크 인덱스를 사용하는 단일 행 조회를 의미
* ref : test.elem.a
  * 참조열 elem.a 로 읽는다는 뜻
* 조인 방법중 eq_ref 가 가장 빠름, 한 행만 일치해서!
  * PK나 유니크 인덱스를 사용해야함

다음은 문법상 같은데, In 목록에서 At 라는 단일값이 제거된 경우 예시

![img_30.png](img_30.png)
![img_31.png](img_31.png)

* 완전히 새로운 EXPLAIN 출력이 나옴
* elem.a 대신 elem_names.symbols 에 대한 값으로 IN 목록을 재작성함
* elem_names.symbols 테이블의 인덱스 사용은 Ag 와 Au 의 두 값으로 조회하기 위한 범위 스캔임을 추정 가능

인덱스 없이 테이블 조인 가능, "풀 조인", 최악의 작업

![img_32.png](img_32.png)
![img_33.png](img_33.png)

* 일반적으로 MySQL은 이 쿼리 실행 계획을 선택하지 않아서 IGNORE INDEX 로 강제 실행한것
* Extra 필드의 Using join buffer (hash join) 은 Mysql 8 에 새롭게 도입된 해시 조인 알고리즘
  * 메모리 내 해싯값 테이블을 만들고, 반복되는 테이블 스캔을 수행하는 대신, 이 해시테이블을 사용해 행을 조회함
  * 해시조인으로 성능이 비약적으로 향상됨, 그러나 가능한 피하셈

## 2-3 인덱싱: Mysql 처럼 생각하는 방법

* 인덱스와 인덱싱은 다른 주제이다.
* 쿼리를 실행할 때 가장 적은 수의 행에 접근할 수 있도록 열을 인덱싱 하는 것이 최선이다.
* 엔지니어로서는 어플리케이션 맥락에서 쿼리를 생각한다.

### 쿼리 알기

다음의 메타 데이터를 수집하는 것으로 시작하기

* SHOW CREATE TABLE 테이블 생성 정보 보기
* SHOW INDEXES 인덱스 정보 보기
* SHOW TABLE STATUS 테이블 상태정보 보기

이후 다음 질문에 답변하기

#### 쿼리

* 쿼리는 몇 개의 행에 접근해야 할까?
* 쿼리는 몇 개의 행을 반환해야 할까?
* 어떤 열이 선택 될까?
* GROUP BY, ORDER BY, LIMIT 절은 무엇일까?
* 하위 쿼리가 있을까?

#### 테이블 접근(테이블마다)

* 테이블 조건은 무엇일까?
* 쿼리는 어떤 인덱스를 사용할까?
* 쿼리가 사용할 수 있는 다른 인덱스는 무엇일까?
* 각 인덱스의 카디널리티는 무엇일까?
* 테이블의 크기는 얼마일까?

### EXPLAIN으로 이해하기

* EXPLAIN 출력의 key 필드부터 시작, 맨 왼쪽 접두사에 대한 요구사항 충족 확인
* posibble_keys 필드에 다른 인덱스가 나열되어 있는지 확인
* Extra 필드에 테이블 접근 방법을 확인

### 쿼리 최적화

* 다르게 실행되지만 같은 결과를 반환하는 쿼리는 여러 방법으로 작성할 수 있다는 것을 인지하기
* 인덱스 변경으로 해결되지 않으면 간접 쿼리 최적화러 여정을 옮기기
* 쿼리 작성 후 인덱스 작업을 하면서 가장 최적화된 방법에 도달할때 까지 반복하기

### 배포와 검증

* 배포를 되돌릴 방법을 확인하고 준비하기
* 배포 후에는 쿼리 매트릭과 MySQL 서버 메트릭으로 변경 사항 검증하기

## 2-4 좋은 인덱스였는데...

### 쿼리 변경

* 쿼리가 변경될 때 맨 왼쪽 접두사에 대한 요구상이 손실될 수 있음을 인지
* 새로 변경한 쿼리에 대해 인덱스를 다시 만들어야함

### 과도하고 중복되며 사용되지 않음

* 과도한 인덱스, 중복 인덱스
  * 인덱스 크기 증가
* 인덱스가 많아지면 더 많은 메모리를 사용함, 각 인덱스에 사용할 수 있는 메모리가 줄어듦
* 인덱스 수가 과도하면 쓰기 성능이 심각하게 떨어짐 (B트리 재구성)
* 인덱스를 삭제할 때는 주의해야 함
  * 인비저블 인덱스 : 인덱스 삭제 전에 인덱스가 사용되지 않거나 필요하지 않은지 확인 가능

### 최고의 선택도

* 카디널리티는 인덱스의 고윳값 수
  * 값 a,a b,b 에 대한 인덱스의 경우 카디널리티는 2임
  * a와 b는 고유한 두 값
* 선택도
  * 카디널리티를 테이블의 행 수로 나눈 값
  * a,a b,b 에 대한 인덱스의 경우 각 값이 1 행일때, 선택도는 2/4=0.5임
  * 선택도는 0에서 1까지
    * 선택도가 1인 인덱스는 모든 행에 대해 값이 각각인 유니크 인덱스
  * 선택도가 매우 낮은 인덱스는 각 고윳값이 많은 수의 행과 일치해 거의 영향력이 없다
    * 예시 : Y/N 처럼 2가지 값만 있는 열의 인덱스
    * 테이블에 행이 10만개일때 선택도는 사실상 0임, 좋은 인덱스가 아님
* 선택도가 매우 낮은 인덱스인 경우, 더 나은 선택도를 갖는 인덱스를 만들 수 있을지 확인하기
* 선택도가 매우 높은 세컨더리 인덱스가 많은 경우
  * 전체 테이블을 보거나 검색하는 접근 패턴을 나타낼 가능성이 높음
  * 엘라스틱 서치로 교체 검토하기

### 이것은 함정이다 - MySQL이 다른 인덱스를 선택할 때

* Mysql 이 인덱스를 잘못 선택하기도 함
  * 일반적 : 많은 수의 행을 갱신할 때 갱신된 행 수가 인덱스 통계의 자동 갱신을 유발하기에는 조금 모자랄때
    * 정확하게는 인덱스 통계가 부정확
  * Mysql은 샘플 페이지에 대한 인덱스를 무작위 탐색함
    * 인덱스 값이 고르게 분포되어 있으면 몇번의 무작위 탐색으로 전체 인덱스 정확하게 표현
  * 인덱스 통계를 갱신하는 경우
    * ANALYZE TABLE 명령어 실행
    * 테이블이 처음으로 열릴 때
    * 마지막 업데이트 이후 테이블의 1/16이 수정되었을 때

## 2-5 테이블 조인 알고리즘

* 중첩 반복 조인 (nested loop join) - 기본 조인 알고리즘
  * 중첩 foreach 문 처럼 작동함 (t1, t2, t3 테이블 예시)
  * ![img_34.png](img_34.png)
  * 만약 t3.C 에 인덱스가 없으면 풀조인
* 중첩 반복 알고리즘은 간단하고 효과적임
  * 가장 안쪽 테이블에 상당히 자주 접근하고 풀 조인을 사용하면 접근 속도가 매우 느려짐
  * t1과 t2 모두 10개의 행이 일치하면 t3에는 100번 접근함
    * 블록 중첩 반복 조인 알고리즘이 이 문제를 해결함
      * t1과 t2에서 일치하는 행의 조인 열값은 조인 버퍼에 저장
        * 조인 버퍼가 가능 차면 t3를 스캔하고 조인 버퍼의 조인 열값과 일치하는 t3 행을 조인함
* mysql 8.0 부터 해시 조인 알고리즘이 블록 중첩 반복 조인 알고리즘은 대체함 
  * 조인 테이블 (t3)를 매모리 내에 해시 테이블로 생성함
  * HashTable 을 사용하여 조인테이블의 행을 조회하여 상수 시간 연산, 매우 빠름

## 요점 정리

이하 생략
