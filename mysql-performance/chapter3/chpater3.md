# 3장 데이터

* 간접 쿼리 최적화를 다루는 장
* 직접 쿼리 최적화가 많은 문제를 해결하지만 전부를 해결해주지 않음
* 데이터는 돌 더미와 유사 (0.5톤인 돌 하나 vs 조약돌 더미 2톤 선택)

## 3-1 세가지 비밀

### 인덱스가 도움이 되지 않을 수 있다

* 좋은 인덱스라도 쿼리가 느릴 수 있다
* 인덱스 조회만 남게 되어도 아이러니한 면이 있다
* 인덱스가 무한한 데이터 크기에 대한 무한한 영향력을 제공하지 않는다

#### 인덱스 스캔

* 테이블이 커질수록 인덱스호 함꼐 커지므로 영향력이 점점 감소한다
* 인덱스 전용 스캔조차 확장성이 부족한 경향이 있다
* 테이블 행 수가 증가할수록 인덱스 스캔을 사용하는 쿼리에 대한 응답 시간도 늘어나므로 지연시간이 발생한다

#### 행 찾기

* 일치하는 행을 찾는것이 쿼리의 기본 목적이지만, 좋은 인덱스를 사용하더라도 너무 많은 행을 검사할 수 있다
* 검사할 행이 너무 많으면 응답시간이 느려진다
* type 필드가 한 행만 조회하는 경우 (system, const, eq_ref, unique_subquery) 가 아니라면 주의!
* 매우 낮은 선택도는 느리게 한다.
  * 세컨더리 인덱스는 프라미어리 키에서 두번째 조회가 필요하다
  * 선택도가 너무 낮으면 풀 테이블 스캔이 빠를 수 있다

#### 테이블 조인

* 조인할떄 각 테이블의 몇개 행이 성능을 빠르게 떨어뜨린다
  * 중첩 반복 조인 알고리즘 : 접근한 행 수 = 각 테이블에 접근한 행의 곱
  * 하나의 행만 일치시키는게 좋음
* 인덱스 조회가 없으면 풀조인이니 주의

#### 작업 세트 크기

* 인덱스는 메모리에 있을 때만 유용, 쿼리가 조회하는 인덱스 값이 메모리에 없으면 디스크에서 읽음
* Mysql은 자주 사용하는 인덱스 값을 메모리에 유지하려고 함
* 작업 세트란? : 자주 사용하는 인덱스값과 이들이 참조하는 프라이머리 키 행
  * 테이블 크기에서 작은 비율 차지 
  * DB의 크기는 500GB, 애플리케이션은 1GB 에만 자주 접근
  * 500GB의 10% 는 50GB, 64GB의 메모리를 할당할 수 있음
* 작업세트의 크기가 메모리보다 커지면 인덱스가 도움이 안됨
  * 스토리지 입출력에 부담을 주고 모든 것을 느리게 만듬
  * 감당할수 없게 많다? 해결책은 샤딩

### 데이터가 적을수록 좋다

* 데이터 크기를 적절하게 유지하는 것이 거대한 데이터베이스를 처리하는 것보다 쉽다
* 제한없이 증가하는 데이터에 문제를 제기해야 한다

### QPS가 낮을수록 좋다

#### QPS는 숫자에 불과하며 원시 처리량을 측정한 값이다

* QPS는 쿼리나 성능에 대한 질적 정보를 제공하지 않는다
  * 1000QPS 에서 SELECT 1 은 리소스가 거의 필요하지 않다
  * 똑같은 QPS 에서 복잡한 쿼리는 모든 시스템 리소스에 많은 부하를 준다
* QPS 가 높다는 것은 쿼리 응답 시간이 좋다는 의미이기도 하다

#### QPS값은 객관적인 의미가 없다

* QPS는 상대적이다
  * 평균 2000QPS 라면 1000QPS는 중단을 나타내는 급격한 하락
  * 평균 300QPS 라면 100QPS 는 정상적인 변동

#### QPS를 높이기는 어렵다

* 데이터 크기는 1GB에서 100GB로 100배정도는 쉽게 증가한다
  * QPS를 100배 높이기는 매우 어렵다
* QPS는 질적이지 않고 애프리케이션과 관련만 있을 뿐, 높이기 어렵다
  * QPS가 낮을수록 좋다. QPS는 도움되지 않는다, 자산보단 부채이다.
