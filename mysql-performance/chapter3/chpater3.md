# 3장 데이터

* 간접 쿼리 최적화를 다루는 장
* 직접 쿼리 최적화가 많은 문제를 해결하지만 전부를 해결해주지 않음
* 데이터는 돌 더미와 유사 (0.5톤인 돌 하나 vs 조약돌 더미 2톤 선택)

## 3-1 세가지 비밀

### 인덱스가 도움이 되지 않을 수 있다

* 좋은 인덱스라도 쿼리가 느릴 수 있다
* 인덱스 조회만 남게 되어도 아이러니한 면이 있다
* 인덱스가 무한한 데이터 크기에 대한 무한한 영향력을 제공하지 않는다

#### 인덱스 스캔

* 테이블이 커질수록 인덱스호 함꼐 커지므로 영향력이 점점 감소한다
* 인덱스 전용 스캔조차 확장성이 부족한 경향이 있다
* 테이블 행 수가 증가할수록 인덱스 스캔을 사용하는 쿼리에 대한 응답 시간도 늘어나므로 지연시간이 발생한다

#### 행 찾기

* 일치하는 행을 찾는것이 쿼리의 기본 목적이지만, 좋은 인덱스를 사용하더라도 너무 많은 행을 검사할 수 있다
* 검사할 행이 너무 많으면 응답시간이 느려진다
* type 필드가 한 행만 조회하는 경우 (system, const, eq_ref, unique_subquery) 가 아니라면 주의!
* 매우 낮은 선택도는 느리게 한다.
  * 세컨더리 인덱스는 프라미어리 키에서 두번째 조회가 필요하다
  * 선택도가 너무 낮으면 풀 테이블 스캔이 빠를 수 있다

#### 테이블 조인

* 조인할떄 각 테이블의 몇개 행이 성능을 빠르게 떨어뜨린다
  * 중첩 반복 조인 알고리즘 : 접근한 행 수 = 각 테이블에 접근한 행의 곱
  * 하나의 행만 일치시키는게 좋음
* 인덱스 조회가 없으면 풀조인이니 주의

#### 작업 세트 크기

* 인덱스는 메모리에 있을 때만 유용, 쿼리가 조회하는 인덱스 값이 메모리에 없으면 디스크에서 읽음
* Mysql은 자주 사용하는 인덱스 값을 메모리에 유지하려고 함
* 작업 세트란? : 자주 사용하는 인덱스값과 이들이 참조하는 프라이머리 키 행
  * 테이블 크기에서 작은 비율 차지 
  * DB의 크기는 500GB, 애플리케이션은 1GB 에만 자주 접근
  * 500GB의 10% 는 50GB, 64GB의 메모리를 할당할 수 있음
* 작업세트의 크기가 메모리보다 커지면 인덱스가 도움이 안됨
  * 스토리지 입출력에 부담을 주고 모든 것을 느리게 만듬
  * 감당할수 없게 많다? 해결책은 샤딩

### 데이터가 적을수록 좋다

* 데이터 크기를 적절하게 유지하는 것이 거대한 데이터베이스를 처리하는 것보다 쉽다
* 제한없이 증가하는 데이터에 문제를 제기해야 한다

### QPS가 낮을수록 좋다

#### QPS는 숫자에 불과하며 원시 처리량을 측정한 값이다

* QPS는 쿼리나 성능에 대한 질적 정보를 제공하지 않는다
  * 1000QPS 에서 SELECT 1 은 리소스가 거의 필요하지 않다
  * 똑같은 QPS 에서 복잡한 쿼리는 모든 시스템 리소스에 많은 부하를 준다
* QPS 가 높다는 것은 쿼리 응답 시간이 좋다는 의미이기도 하다

#### QPS값은 객관적인 의미가 없다

* QPS는 상대적이다
  * 평균 2000QPS 라면 1000QPS는 중단을 나타내는 급격한 하락
  * 평균 300QPS 라면 100QPS 는 정상적인 변동

#### QPS를 높이기는 어렵다

* 데이터 크기는 1GB에서 100GB로 100배정도는 쉽게 증가한다
  * QPS를 100배 높이기는 매우 어렵다
* QPS는 질적이지 않고 애프리케이션과 관련만 있을 뿐, 높이기 어렵다
  * QPS가 낮을수록 좋다. QPS는 도움되지 않는다, 자산보단 부채이다.

## 3-2 최소 데이터 원칙

필요 데이터만 저장하고 접근하라

### 데이터 접근

* 필요 이상으로 많은 데이터에 접근하지 마라
* 데이터 접근이 효율적일때 MySQL 은 거의 인메모리 캐시처럼 작동한다

#### 필요한 열만 반환 

* SELECT * 쿼리를 실행하지 마라
  * BLOB, TEXT, JSON 열이 있을때 특히 중요

#### 쿼리 복잡성 감소

* 처음부터 쿼리를 단순하게 유지하고 될 수 있으면 쿼리 복잡성을 줄여라

#### 행 접근 제한

* col > 75 와 같은 개방형 범위, 테이블이 커짐에 따라 행 접근이 사실상 제한되지 않음
* Mysql 이 인덱스 순서대로 접근할 수 있을때 LIMIT, 일치하는 행을 찾다가 LIMIT 수만큼 발견되면 행읽기를 중지함

#### 결과 세트 제한

* 쿼리는 될수 있는 한 적은 수의 행을 반환해야 함
* 전체 결과세트를 사용하지 않는 애플리케이션을 나타냄
* 세가지 유형 (잘못된 유형)
  1. 애플리케이션이 일부 행을 사용할 때
     1. where 조건을 사용하는 대신 행을 필터링 하는 애플리케이션 코드
        1. 복잡한 쿼리를 피하는 방법임
        2. 응답시간을 단축할 때만 유용함
  2. Order By 절이 있고 애플리케이션이 정렬된 행의 일부분을 사용할 때
     1. 첫번째와 다르게 행의 순서가 결정적인 특징
     2. LIMIT 20을 사용하지 않고 1000개가 쿼리해서 20개만 사용하는 경우
        1. 페이징을 하려고 이렇게 짠 경우가 있다
        2. LIMIT 20 OFFSET N 이 더 효율적일 수 있다
  3. 애플리케이션이 결과 세트를 집계하기만 할 때
     1. ex) 행의 개수를 애플리케이션이 직접 세는 경우가 있음 -> count(*) 사용해야함

### 데이터 스토리지

필요 이상으로 많은 데이터를 저장하지 마라

* 필요한 행만 저장됨
  * 애플리케이션이 무얼 저장하는지 검토한지 오래되었으면 다시 검토해야함
* 모든 열이 사용됨
  * 유일한 해결책은 수동 검토
* 모든 열이 간결하고 실용적임
  * 가장 작은 데이터 타입을 사용하여 값을 저장
  * 안티패턴은 varchar(255)
* 모든 값이 간결하고 실용적임
  1. 압축
     1. 문자열 " and " 를 압축하는 6가지 방법
        * "and"
        * " and"
        * "and "
        * ""
        * "&"
        * NULL : 매직 문자열 대신 null 사용으로 데이터 아끼기
  2. 인코딩
     * 안티패턴
       * IP 주소를 문자열로 저장하는 경우
       * IP 주소는 4byte의 부호 없는 정수
         * INT_ATON, INET_ATON, INET_NTOA 함수를 사용하여 인코딩
     * UUID를 문자열로 저장하는 경우
  3. 중복 제거
     * 중복값을 제거하려면 열을 1:1 관계 테이블로 분리하고 참조 해야함
     * 의도적으로 중복을 만들어서 성능을 향상시키는 경우도 있음 (비정규화)
* 모든 세컨더리 인덱스가 사용되며 중복되지 않음
  * 사용되지 않고 중복된 세컨더리 인덱스를 삭제하는 것은 데이터 크기를 줄이는 쉬운 방법
  * 인덱스 크기를 주기적으로 확인하고 정리해야함 (SHOW TABLES STATUS)
* 필요한 행만 유지됨
  * 1번항목 "필요한 행만 저장됨" 을 시작으로 해서, 저장된 행은 시간이 지남에 따라 필요 여부 확인 후 삭제
  
## 3-3 데이터 삭제 또는 보관

### 도구

* 데이터를 삭제하거나 보관하려면 도구를 직접 작성해야함
* 도구를 작성할때 유의할 점
  * 배치 크기를 안전하게 하여 애플리케이션이 중단되지 않게 유의
    * ex) LIMIT 100000 에 for 문으로 지우는 것

### 배치 크기

* 행이 작고 Mysql에 큰 부하가 없을때, 단일 DELETE 문으로 1000개 이하의 행을 수동 삭제하는것이 안전 (병렬이 아닌 직렬)
* 각 DELETE 문은 실행하는데 500ms 를 넘지 않아야함

#### 복제 지연

* DELETE 문을 실행하는데 500ms 가 걸렸다면, 복제본에서도 500ms 가 걸릴 것, 최소화 해야함

#### 스로틀링

* 배치 크기를 500ms 으로 보정하려면 배치 크기를 LIMIT 1000, DELETE문 사이에 200ms의 지연을 두기
* 돌려보고 재실행 할 때 마다 지연을 천천히 줄여 프로세스를 반복해보기
* 배치 크기를 보정하고 스로틀을 설정하면 쿼리 응답 시간에 영향을 주지 않고 삭제할 수 있는 초당 행 수인 DELETE QPS 를 계산할 수 있음

### 로우 락 경합

* 쓰기 작업이 많은 경우 대량 작업으로 로우 락 경합이 발생할 수 있음
* Mysql은 500ms 내에서 십만개의 행을 삭제할 수 있지만, 애플리케이션이 갱신하는 행과 겹치면 로우 락 경합
* 해결책은 더 짧은 시간 (100ms) 으로 보정해여 배치크기 줄이기

### 공간과 시간

* 데이터를 삭제해도 디스크 공간이 확되지 않는다 (행 삭제는 논리적)
* 500GB 를 삭제하면 500GB의 디스크가 아닌 500GB의 여유 페이지가 생긴다
* 새 행시 삽입될때 여유 페이지를 재사용 하게 된다, 삭제된 행이 곧 새 행으로 교체
* 디스크 공간을 회수하는 방법은 ALTER TABLE... ENGINE=InnoDB 를 사용하여 테이블을 재생성하는 것

### 바이너리 로그 역설

* 데이터를 삭제하면 데이터가 생성된다.
* 위 역설은 데이터 변경사항이 바이너리 로그에 기록되기 때문
* BLOB, TEXT, JSON 열이 포함된 경우 바이너리 로그 크기가 급격히 증가할 수 있다
* 서버에 데이터를 삭제하고 테이블을 재구성하기에 충분한 디스크 여유 공간이 있는지 확인 필요
