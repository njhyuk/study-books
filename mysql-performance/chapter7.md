# 7장 복제 지연
복제 지연은 원본 Mysql 인스턴스에서 쓰기가 발생하는 시간과 해당 쓰기가 복제 인스턴스에 적용된느 시간 사이의 지연입니다.
## 7-1 Mysql의 복제 유형
* 원본에서 복제본으로 (soruce to replica)
    * 20년 이상 사용해온 기본 복제 유형
* 그룹 복제
    * 5.7.17버전부터 지원하는 새로운 복제 유형
    * 그룹 합의 프로토콜을 사용하여 데이터 변경 사항을 동기화
    * 그룹 구성원을 관리하는 기본과 보조 인스턴스의 MySQL 클러스터 생성
    * 책에서는 다루지 않음 (일반적이지 않다.)
### 원본에서 복제본으로  (soruce to replica)
* 원본 MySQL 인스턴스
    * 클라이언트가 데이터를 쓰는 MySQL 서버
    * 쓰기 가능한 단일 원본이 일반적
* 복제본 MySQL 인스턴스
    * 원본에서 데이터 변경 사항을 복제하는 모든 MySQL 서버
    * 항상 읽기 전용임
* 데이터 변경 흐름
    * 데이터 변경사항이 원본 바이너리 로그에 기록
    * 복제본의 I/O 스레드가 원본 바이너리 로그에서 바이너리 로그 이벤트를 덤프
    * 복제본의 I/O 스레드는 복제본의 릴레이로그에 바이너리 이벤트를 기록
    * SQL 스레드는 릴레이 로그에서 바이너리 로그 이벤트를 읽음
    * SQL 스레드는 바이너리 로그 이벤트를 복제본 데이터에 적용
    * 복제본은 데이터 변경사항을 바이너리 로그에 기록
* MySQL 복제는 비동기식이 기본
    * 원본에서 트랜잭션은 1단계 후에 완료, 나머지 단계는 비동기식
    * 반동기식도 지원함 (slave 가 ack를 받아야 커밋)
* 복제본이 원본이 될 수 있음 (고가용성 failover를 위함)
    * 이전 원본을 복원하고 새 원본에서 복제
### 바이너리 로그 이벤트
바이너리 로그 이벤트는 애플리케이션이 실행한 트랜잭션의 직접적인 결과
```
BEGIN;
UPDATE t1 set c='val' WHERE id=1 limit 1;
DELTE from t2 limit 3;
COMMIT;
```
4개의 연속 이벤트가 트랜잭션을 구성함
* BEGIN 이벤트
* 1개의 행 이미지가 있는 UPDATE 문에 대한 이벤트
* 3개의 행 이미지가 있는 DELETE 문에 대한 이벤트
* COMMIT 이벤트
### 복제 지연
* 복제지연은 복제본에 변경 사항을 적용하는것이 원본에 변경 사항을 커밋하는 것 보다 느릴때 발생
* 복제본의 I/O 스레드는
    * 네트워크에서 읽고 디스크에 차례대로 쓰는 비교적 쉬운 과정이므로 바이너리 로그 이벤트를 릴레이 로그에 빠른 속도로 쓸 수 있다.
* SQL 스레드에는
    * 변경사항을 적용하는 것이 훨씬 더 어렵고 시간이 많이 걸린다.
* 단일 SQL 스레드는 복제 지연을 유발하지 않으며 제한 요소일 뿐이다.
    * 원인은 원본의 트랜잭션이 높아서이다.
    * 해결척은 더 많은 SQL 스레드가 필요한 것이다.
* 복제에는 지연이 따르기 마련이지만 MySQL 복제는 매우 빠르다.
    * 단일 SQL 스레드는 초당 수천 건의 트랜잭션을 쉽게 처리할 수 있다.
    * 복제본은 원본이 실행하는 전체 워크로드를 실행하지 않는다.
* 복제본은 SQL 문을 실행하지 않고 바이너리 로그 이벤트를 적용한다.
## 7-2 복제 지연의 3가지 원인
### 트랜잭션 처리량
* 트랜잭션 처리량은 원본의 속도가 복제본의 SQL 스레드가 변경 사항을 적용할 수 있는 속도보다 빠를때 복제지연 유발
* 원본쪽의 속도를 줄일 수 없음, 더 많은 SQL 스레드를 실행하여 복제본의 속도를 높이기
* 과도하게 많은 행을 수정하는 대규모 트랜잭션은 원본보다 복제본에 더 큰 영향
    * 단일 스레드 복제본에서 2초가 걸리는 트랜잭션은 다른 모든 트랜잭션을 차단
    * 해결책은 작은 트랜잭션
### 장애 후 재구축
* MySQL이나 하드웨어에 장애가 발생하면 새 인스턴스가 기존 인스턴스에서 복제되어 실패한 인스턴스를 대신함, 고가용성을 회복하기 위해 복제 토폴로지가 재구축됨
* 수리된 인스턴스는 오프라인 상태에서 놓친 모든 바이너리 로그 이벤트를 복제하는데 몇분, 몇시간, 며칠이 걸림
### 네트워크 문제
네트워크 문제로 원본에서 복제본으로 바이너리 로그 이벤트 전송이 지연되면 복제지연이 발생함
## 7-3 위험: 데이터 손실
### 비동기식 복제
* 원본이 5개의 트랜잭션을 커밋하고, 충돌이 발생할때 복제 I/O 스레드가 3개만 가져오고 2개의 트랜잭션이 손실되었을 수 있음
* 충돌 원인이 MySQL이라면 자동으로 다시 시작하고 충돌 복구를 수행함
* 하드웨어나 운영체제가 충돌의 원인인 경우 DBA가 장애조치 (원본을 복제본으로 대체) 함
* 모든 HW/SW는 장애가 발생하므로 비동기식 복제를 사용할 때 데이터 손실은 불가피함
* 많은 기업이 비동기식 MySQL 복제를 사용하지만, 더 높은 표준인 반동기식 복제를 사용하도록 노력 해야함
> AWS Aurora DB 는 비동기식 복제인듯
### 반동기식 복제
* 반동기식 복제는 원본은 적어도 하나의 복제본이 각 트랜잭션을 승인할 때까지 기다림 (ack)
* 확인 응답은 복제본이 트랜잭션에 대한 바이너리 로그 이벤트를 릴레이 로그에 기록했음을 의미
* 확인 응답을 적용할때가 아니라 수신했을 때 보내므로 반동기
* 커밋된 모든 트랜잭션이 적어도 하나의 복제본에 복제 되었음을 보장
* 4단계
    * 트랜잭션 커밋 준비
    * 데이터 변경 사항을 바이너리 로그로 플러시
    * 하나 이상의 복제본에서 응답 대기
    * 트랜잭션 커밋
* 반동기식 복제는 가용성을 떨어뜨림, 트랜잭션이 지연, 시간초과, 또는 commit 에서 실패할 수 있음
## 7-4 지연 감소: 다중 스레드 복제
* MySQL 복제는 비동기식이고 단일 스레드, 복제본에 하나의 SQL 스레드
* 해결책은 다중 스레드 복제, 다중 SQL 스레드는 트랜잭션을 병렬로 적용
* MySQL 로서는 간단하지 않음, 트랜잭션이 무작위 순서로 적용될 수 없음
* 시스템 변수
    * replica_parallel_workers : 적용자 스레드, 4로 시작 추천
    * replica_parallel_type  : 기본값 DATABASE, 서로 다른 DB에 대해서만 트랜잭션 병렬
    * relica_preserver_commit_order : 기본적으로 비활성화, 순서에 맞지 않게 커밋
## 7-5 모니터링
* 복제 지연을 모니터링 가능 가장 좋은 방법은 전용 도구를 사용하는 것 Second_Behind_Source
* 복제 지연 메트릭 Second_Behind_Soruce
    * 복제본의 현재 시각이 T=100
    * SQL 스레드가 타임스탬프 T=80인 바이너리 로그 이벤트를 실행 중이면?
    * Second_Behind_Soruce 는 20임
* Second_Behind_Soruce 의 문제점
    * 모든것이 작동하지 않을 때
        * SQL 스레드는 모든 바이너리 이벤트를 적용하고 메트릭을 0으로 보고함
    * 0과 0이 아닌 값 사이를 반복함
        * 첫번째 문제와 관련 있음, 한순간에 500, 다음순간에는 0, 잠시후 다시 500
    * 복제본이 언제 따라 잡을지 정확한 답을 못함
        * 적용중인 현재 이벤트가 원본에서 실행됐는지 얼마나 지났는지만 나타냄
## 7-6 복구 시간
* 복제본에 상당한 지연 시간이 발생할 때 가장 시급한 질문은 언제 복구될 것인가?
* 복구 시점은 Second_Behind_Soruce 메트릭이나 도구에 보고된 값보다 빠르다
* 복제지연에도 불구하고 복제본이 원본을 둘러싼 전체 워크로드를 실행할 필요가 없으므로 단일 SQL 스레드는 매우 빠르다
* 복제본은 종종 원본보다 빠르게 트랜잭션을 적용, 이것이 복제본이 따라잡는 방법
* MySQL은 항상 원인이 해결되면 결국 복구된다


> 복제지연으로 이슈있던 사례?
