# 4장 접근 패턴

## 4-1 MySQL은 아무것도 하지 않는다

* 애플리케이션이 유휴상태일때 MySQL은 유휴 상태이다.
* 일부 페이지 플러싱 같은 백그라운드 작업은 있으나, 쿼리들에 대한 데이터를 읽고 쓰는데도 바쁘다.
* 느린 쿼리의 원인은 애플리케이션이다.
* 쿼리 경합
  * 쿼리는 다른 쿼리에 영향을 준다.
  * 로우 락 경합, CPU 경합
  * MySQL은 로우 락 경합이라는 한가지 유형의 경합만 보고한다.
    * 쿼리 경합을 보거나 증명하는 것은 거의 불가능하다.
    * 이유 : 로우락 경합도 로우 락이 복잡하기 때문에 정확하게 확인하기 어렵다.

## 4-2 한계에 도달하면 성능이 불안정해진다

* 선형 스케일링
  * DB 성능은 하드웨어 처리량을 100% 사용할때 까지 증가한 다음, 성능이 일정하게 유지된다.
    * 이를 선형 스케일링 이라 한다.
  * 선형스케일링은 이상적이지만 실현되기 어렵다.
    * 현실적으로 DB 성능의 한계는 시스템 처리량의 80~95% 정도이다.
    * 부하가 한도를 초과하여 증가하면 성능이 불안정해진다.
* 운영 중단의 전조 증상
  * 상승기
    * 메트릭이 꾸준히 상승
  * 한계점
    * CPU 사용량과 QPS는 꾸준히 높은 상태로 유지중
    * 실행중인 스레드의 톱날패턴이 MySQL이 불안정해졌음을 나타내는 신호
    * 하나의 쿼리를 실행하는데는 하나의 스레드가 필요함
      * 실행중인 스레드의 큰 변동은 쿼리가 원활하지 않다는 뜻
  * 수정
    * 개발자가 애플리케이션 레벨 트랜잭션 처리량을 줄임
    * CPU 사용량이 50%로 떨어지고 QPS와 스레드도 안정됨
* 한계에 도달한 Mysql 성능에 대해
  1. 일부러 부족한 하드웨어를 사용하지 않는 한, 한계에 도달하기 어렵다.
     * 애플리케이션은 모든 하드웨어를 동시에 완전히 활용하기 전에, 병목 현상을 일으킨다.
       * DB 성능의 한계가 아닌 하드웨어의 한계에 도달한 것이다.
  2. 높은 부하로 인해 MySQL이 느리게 응답한다고 해서 한계에 도달했다는 의미는 아니다.
     * 동시성이 증가하면 한계가 증가함, 느려진게 한계가 도달했다는건 아님

## 4-3 도요타와 페라리

* 두 자동차 브랜드 거의 똑같은 부품과 디자인을 사용한다.
* 하지만 페라리가 더 빠르다.
* 도요타는 고속 주행을 목표로 설계되지 않았고, 페라리는 모든 부분이 고속 주행을 목표로 설계되었다.
* MySQL의 성능을 높이기 위해 같은 관점으로 데이터 접근패턴을 설계할 수 있다.

## 4-4 데이터 접근 패턴

* 애플리케이션이 MySQL을 사용하여 DB에 접근하는 방법이다.
* 접근 패턴에 대한 3가지 세부 정보
    1. 접근 패턴은 개별적으로 수정해야 한다.
    2. 쿼리가 초점이 아니다.
       1. 쿼리는 구현이다. 인터페이스에 집중해야 한다.
          1. ex) 특정 접근 패턴은 MySQL 보다 key-value 스토리지가 적합
    3. 접근 패턴은 이름과 기술적인 특성 목록으로 구성된다.
       1. 이름 : 접근 패턴을 다른 엔지니어와 소통하는데 사용
       2. 기술적인 특성 목록 : 데이터 스토리지에 따라 접근 방법이 다름 (MySQL vs key-value)

### 읽기/쓰기

* SELECT : 명확한 읽기 접근
* INSERT..SELECT : 읽기와 쓰기 접근
* UPDATE, DELETE : WHERE 절이 있어서 읽기와 쓰기 접근 가능
* INSERT, UPDATE, DELETE : 쓰기 접근 (DELETE 도 쓰기 접근, 내부적으로 다른 쓰기)
* 모든 읽기는 같고 모든 쓰기는 같다.
* 읽기 확장은 offload 하여 수행함 (4장 5절에서 다룸)
* 쓰기 확장은 샤딩으로 확장 (5장에서 다룸)

### 처리량

* 처리량 (QPS) 는 성능이 아니다.
  * 1QPS 만으로 엄청난 피해를 줄 수 있다.
    * ex) 테이블 스캔을 수행하고 모든 행을 잠구는 SELECT...FOR UPDATE
* 매우 높은 QPS 는 해결해야 하는 문제 (QPS는 낮을수록 좋다)

### 데이터 수명

* 데이터 수명은 시간이 아니라 접근 순서에 상대적
  * 10분동안 백만개의 행 삽입
  * 첫번째 행은 10분밖에 안지난건데 가장 오래된 행이 됨
  * 첫번째 행을 갱신하면 가장 최신 행이 됨
* 이 특성은 작업 세트에 영향을 미치기에 중요함
  * MySQL은 될 수 있는 한 많은 데이터를 메모리에 보관함
  * 데이터에 접근하지 않으면 오래되어 결국 메모리에서 제거됨
* 오래된 데이터를 자주 접근하는것도 문제가 된다.
  * 기본 개념
    * 데이터는 여유 페이지 (메모리 내) 에 적재됨
    * 사용할 수 있는 여유 페이지가 있을때는 정상
    * 문제는 스토리지에서 데이터를 읽는 것은 속도가 느리다는 것
    * 비정상적으로 여유페이지가 하나도 없다면 더 문제가 된다.
  * 설명
    * MYSQL은 가장 최근 사용한 (LRU) 목록에서 추적하여 오래된 페이지를 제거한다.
    * 오래된 페이지가 dirty (데이터 변경 사항이 디스크에 유지되지 않는 경우) 일 때 MySQL 은 이를 제거할때 flush 한다.
      * flush 는 속도가 느리다.
    * 스토리지에서 데이터를 읽는 속도가 느리다.
    * 즉 오래된 데이터를 자주 가져오는것은 성능에 문제가 있다.

### 데이터 모델

* MySQL은 관계형 스토리지 이지만, 키-값 문서, 복잡한 분석, 그래프 등과 같은 다른 데이터모델도 지원
* 비관계형은 MySQL에 상당히 부적합
* MySQL은 키-값 으로도 잘 작동하지만 특별히 제작된 키-값 스토리지가 더 나음 (RocksDB)
* 유일한 옵션이 MySQL일때 접근 방식이 관계형
* 모범사례는 접근 방식에 이상적인 데이터 모델을 결정, 해당 데이터 모델로 구축된 데이터 스토리지를 사용하는 것

### 트랜잭션 격리

* 격리성은 ACID (원자성, 일관성, 격리성, 지속성) 중 하나이다.
* 모든 쿼리는 단일 SELECT 문을 포함하여 트랜잭션에서 실행된다.
* 따라서 접근이 필요하든 필요하지 않든 격리된다.
* 엔지니어가 사용하는 격리 수준의 범주
  * 없음
    * 비트랜잭션 스토리지 엔진에서도 올바르게 실행될때, 격리는 쓸모없는 오버헤드일 떄
  * 기본
    * 격리가 필요하지만 어떤 수준이 필요한지 모르는 경우
    * 기본 격리 수준인 REPEATABLE READ 으로 작동
  * 특정
    * 다른 트랜잭션과 동시에 실행되는 트랜잭션, 특정 격리 수준이 필요할 때
* 일반적인 범주는 기본을 사용한다.
* 그러나 '없음' 이나 '특정' 인것이 좋다.
  * 격리가 필요하지 않다면 트랜잭션 데이터 스토리지가 필요하지 않을 수 있다.
  * 격리가 필요하다면 격리 수준과 그 이유를 구체적으로 알 수 있다.
  * 필요한 격리 수준과 이유를 안다면 다른 MongoDB 같은 스토리지로 전환할 수 있다. 

### 읽기 일관성

* 강력한 일관성은 읽기가 가장 최신 값을 반환함을 의미
  * 강력한 일관성이 원본 MySQL 인스턴스의 유일한 옵션임
  * DynamoDB는 최종 일관성 읽기가 기본이고 강력한 일관성은 느리고 비쌈
* 최종 일관성은 읽기가 이전 값을 반환할 수 있지만, 나중에는 현재 값으로 반환함
  * MySQL 복제본은 1초 미만의 복제지연으로 차이가 발생하지만, 최종적 일관성임
* MySQL 세계에서는 기본적으로 모든 읽기가 강력하게 일관적
  * 그러나 읽기에 강력한 일관성이 요구되지 않는 경우도 많다.
  * 최종적 일관성이 허용되면 읽기 오프로드를 할 수 있다.

### 동시성

* 동시성이 제로라면 동시에 같은 데이터를 읽거나 쓰지 않는다는 것을 의미
  * ex) 고유한 행을 삽입하는 접근 패턴
* 동시성은 로우락이 얼마나 중요한지 나타냄
  * 응답시간은 lock wait timeout 이 발생하기 전까지만 허용됨
  * 이런 상황이 발생하면 동시성을 낮추거나 샤드 구성밖에 답이 없다
* 동시성은 읽기 접근에 캐시를 얼마나 적용할 수 있는지를 나타냄
  * 자주 변경되지 않을땐 캐시에 적합

### 행 접근

* 행에 접근하는 법
  * 포인트 접근 (point)
    * 알파벳을 사용하는 경우 포인트 접근은 임의의 단일 문자 (A)
  * 범위 접근 (range)
    * 순서대로 정렬된 문자 (ABC)
  * 임의 접근 (random)
    * 무작위 문자 (ASMR)
* 이 특성은 쓰기 접근에 중요하다
  * 갭 락
    * range, random 접근 쓰기는 갭 락으로 인해 로우락 경합을 악화시킴 (8장에서 설명)
  * 데드락
    * 데드락은 두 트랜잭션이 다른 트랜잭션에 필요한 로우 락을 보유하는 경우
    * MySQL이 감지하고 해제하지만, 성능을 떨어뜨림
* 행 접근은 샤딩 방법을 계획할 때도 중요, 효과적으로 샤딩하려면 접근 패턴이 단일 샤드를 사용해야 함
  * 포인트 접근은 하나의 행 하나의 샤드와 같은 샤딩에서 가장 잘 작동
  * 범위와 임의 접근은 너무 많은 샤드에 접근, 이점을 무효화 할 수 있음 (5장에서설명)

### 결과 세트 

* GROUP BY, ORDER BY, LIMIT 절이 있다?
  * 접근 방법이 어떻게 변경될지, 어떻게 실행될지에 대한 영향을 미침
  * 행을 그룹화 하거나 정렬하는 접근 방법을 최적화 해야 함
  * 다른 데이터 스토리지에서는 행에 그룹과 또는 정렬을 지원하지 않을 수 있음

## 4-5 애플리케이션 변경

* 데이터 접근 패턴을 변경하려면 애플리케이션을 변경해야 함
* 코드 변경과 더불어 인프라 변경도 필요함
* 최적화중 가장 많은 노력이 필요한 애플리케이션 변경이 마지막 여정

### 코드 감사

* 찾아봐야 할 쿼리
  * 데이상 필요하지 않은 쿼리
  * 너무 자주 실행되는 쿼리
  * 너무 빠르거나 자주 재실행되는 쿼리
  * 크거나 복잡한 쿼리
* 코드가 ORM 이나 모든 종류의 DB 추상화를 사용하는 경우 기본값 확인
  * SHOW WARNING을 실행하는 경우가 많음, 많은 낭비

### 오프로드 읽기

* 오프로드란? 주장치 대신 보조장치에서 처리
  * 오프로드 읽기란 읽기를 복제본이 위임
* 읽기를 오프로드하여 성능을 향상시킬 수 있음
  * MySQL 복제본이나 캐시 서버를 제공하여 읽기 작업을 처리
  * 2가지 방법으로 성능 개선
    * 소스의 부하를 줄이고 나머지 쿼리를 더 빠르게 실행시켜 여유 시간과 시스템 리소스를 확보
    * 읽기를 제공하는 복제본이나 캐시가 쓰기에 사용되지 않으므로 오프로드된 읽기에 대한 응답 시간이 향상됨
* 복제와 캐시 쓰기에는 고유하고 피할 수 없는 지연이 있음
  * 현재 값을 보장하지 않음, 최종적 일관성
  * 즉 오래된 데이터 읽기가 허용되게 됨, 서비스에 문제를 일으키지 않아야함
* 약간 오래된 값을 반환해도 되는 서비스면?
  * 좋아요나 투표 수
    * 현재 값이 100 이지만 캐시가 98을 반환
    * 몇 ms 후에 현재 값을 반환한다면?
      * 이것이 맞지 않다면 오프로드 읽기를 사용하면 안됨
* 또한 다중 명령문 트랜잭션의 일부가 아니어야함
* 애플리케이션이 오프로드 읽기를 하면 복제본 성능에 크게 의존하는 경향이 있다
  * 복제본이 죽어서 성능이 저하된 상태로 실행되도록 애플리케이션을 설계해야함
* 모든 읽기를 오프로드 하면 안된다
  * 느린 읽기를 오프로드 하는것부터 시작해야 한다

### MySQL 복제본

* MySQL 복제본으로 읽기를 제공하는 서비스는 일반적
* 복제본은 3가지 이유로 캐시 서버보다 선호됨
  * 가용성
    * 복제본은 고가용성에 기반, 소스와 같은 가용성을 가져야 함
    * MySQL을 관리하는 사람은 복제본도 관리 할 수 있음, 복제본은 거의 걱정할 필요 없음
  * 유연성
    * 캐시 서버의 CPU와 메모리는 구성 매개변수에 따라 제한됨
    * 고가용성을 위해 사용되는 경우 복제본은 소스와 같은 하드웨어를 가져야 하므로 여유 리소스가 있음
    * 즉 사소한 읽기를 복제본으로 오프로드 하는것은 큰 영향 X, 오프로드할 항목을 선택할 때 유연함
    * 그러나 비용 절감을 위해 작은 CPU와 메모리로 읽기 복제본을 제공하는 경우, 주의해야 함
  * 단순함
    * 애플리케이션을 캐시르 사용하면 갱신, 무효화, 제거를 관리해야 함
    * 진정한 단순함, 복제본에 쿼리 변경이 필요하지 않음

### 캐시 서버

* 캐시 서버는 SQL, 트랜잭션, 지속성 있는 스토리지로 인해 방해받지 않음
* 따라서 MySQL 보다 매우 빠르지만 제대로 사용하려면 애플리케이션에서 손이 조금 간다.
  * 캐시 갱신, 무효화, 제거 관리
* Memcached, Redis 는 널리 사용되는 캐시 서버
* 자주 접근하지만 드물에 변경되는 데이터에 적합
  * 나쁜 예는 항상 변경되는 유닉스 타임스탬프
  * 타임스탬프가 초당 백만번 요청되면 캐싱하는게 적절할수도?
  * 좋은 예는 자주 변경되지 않는 현재 연도
    * 그러나 초당 한번 요청되면 캐시는 가치가 없음
* 캐시를 사용할 때 주의점
  * 캐시가 일시적인지 지속 가능한지
    * MySQL 복제본은 지속성이 좋아서 고려 사항이 아님
  * 일부 애플리케이션은 캐시가 누락 되었을 때 캐시를 재작성 (Cache Aside 패턴?)
  * 캐시에 너무 의존하거나 너무 커서 재구성이 불가능한 경우도 있음
    * 이럴경우 지속성이 뛰어난 캐시가 필요

### 쓰기 대기열에 넣기

* 대기열을 사용하여 쓰기 처리량 안정화
* 불안정한 쓰기 처리량으로 성능을 수용할 수 있떠라도, 규모에 따라 악화될수 있음 (불안정)
* 예측 가능하게 응답할 수 있다는 점, 운에 의존하지 마세요
* 대기열을 사용하면
  * 엄청난 양의 요청들이 MySQL에 영향을 주지 않음
  * MySQL이 오프라인일때 변경사항을 적용할 수 있음
  * 대기열이 카프카라면 변경 사항을 재실행 할 수 있음

### 데이터 분할

* 데이터를 삭제하거나 보관할 수 없을 때 데이터를 물리적으로 분리 해야함
* 파티셔닝
  * 사용하지 않는것이 좋음. (유지보수가 쉬운일이 아님)
* 애플리케이션 개발자가 구현하기 유용한것
  * 핫 데이터와 콜드 데이터를 분리하는 것
  * 접근별로 파티션을 나누기, 자주 접근하지 않는 데이터를 별도 보관
    * ex) 핫 데이터는 지난 90일 동안의 결제, 콜드 데이터는 지난 결제
* 그래서 어떻게?
  * 문서나 키-값 스토리지에 콜드 데이터를 저장
  * 같은 DB 다른 테이블에 보관

### MySQL을 사용하지 않기

* MySQL이 접근 패턴에 적합하지 않을때 MySQL을 사용하지 않기
* 그래프 데이터는 그래프 데이터 스토리지
* 시계열 데이터는 시계열 데이터베이스나 열 기반 스토리지
* MySQL은 최선의 선택이 아닐때도 광범위한 데이터와 접근 패턴에 대해 놀라운 확장성을 제공함
  * 그러나 당연하지 여기지 않기

## 4-6 더 좋고 빠른 하드웨어?

* 하드웨어를 확장해야 하는 정확한 시점은 언제일까?
  * 접근 패턴을 수정할 떄 까지 하드웨어를 확장하지 말라
    * ex) MySQL을 대기열로 사용하고 빠르게 폴링하는 접근 패턴
  * 점검표 작성
    * 모두 체크되면 하드웨어 확장
      * 응답 시간이 너무 길다
      * 느린 쿼리가 최적화 되었다
      * 데이터가 삭제 또는 보관되었다
      * 접근 패턴을 검토하고 최적화했다
    * 적어도 2개 이상 체크 되면 하드웨어 확장
      * CPU 사용률이 80% 이상이다
      * 실행중인 스레드가 CPU 코어 수보다 많다
      * 메모리가 전체 데이터 크기의 10% 미만이다
      * 스토리지 IOPS 사용률이 80% 이상이다

### 읽기 집약

* 읽기 집약적인 접근 패턴에서 지속적으로 높은 IOPS는..
  * 부족한 IOPS가 아니라 메모리 부족때문일 수도 있음
* MySQL은 데이터가 메모리에 없을 때 디스크에서 읽으며, 작업세트를 메모리에 보관하는데 뛰어남
* 작업 세트가 메모리 보다 훨씬 크고 읽기 처리량이 유난히 높다면 읽기 IOPS가 높아질 수 있다

### 쓰기 집약

* 쓰기 집약적인 접근 패턴에서 지속적으로 높은 IOPS는..
  * IOPS가 충분하지 않기 떄문일 수 있음
* 스토리지는 쓰기 캐시로 높은 처리량을 달성하지만, 캐시는 지속성이 떨어짐
  * MySQL에는 캐시가 아닌 디스크에 물리적으로 데이터를 저장하는 지속성 있는 스토리지가 필요함
