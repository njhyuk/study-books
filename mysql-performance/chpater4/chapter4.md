# 4장 접근 패턴

## 4-1 MySQL은 아무것도 하지 않는다

* 애플리케이션이 유휴상태일때 MySQL은 유휴 상태이다.
* 일부 페이지 플러싱 같은 백그라운드 작업은 있으나, 쿼리들에 대한 데이터를 읽고 쓰는데도 바쁘다.
* 느린 쿼리의 원인은 애플리케이션이다.
* 쿼리 경합
  * 쿼리는 다른 쿼리에 영향을 준다.
  * 로우 락 경합, CPU 경합
  * MySQL은 로우 락 경합이라는 한가지 유형의 경합만 보고한다.
    * 쿼리 경합을 보거나 증명하는 것은 거의 불가능하다.
    * 이유 : 로우락 경합도 로우 락이 복잡하기 때문에 정확하게 확인하기 어렵다.

## 4-2 한계에 도달하면 성능이 불안정해진다

* 선형 스케일링
  * DB 성능은 하드웨어 처리량을 100% 사용할때 까지 증가한 다음, 성능이 일정하게 유지된다.
    * 이를 선형 스케일링 이라 한다.
  * 선형스케일링은 이상적이지만 실현되기 어렵다.
    * 현실적으로 DB 성능의 한계는 시스템 처리량의 80~95% 정도이다.
    * 부하가 한도를 초과하여 증가하면 성능이 불안정해진다.
* 운영 중단의 전조 증상
  * 상승기
    * 메트릭이 꾸준히 상승
  * 한계점
    * CPU 사용량과 QPS는 꾸준히 높은 상태로 유지중
    * 실행중인 스레드의 톱날패턴이 MySQL이 불안정해졌음을 나타내는 신호
    * 하나의 쿼리를 실행하는데는 하나의 스레드가 필요함
      * 실행중인 스레드의 큰 변동은 쿼리가 원활하지 않다는 뜻
  * 수정
    * 개발자가 애플리케이션 레벨 트랜잭션 처리량을 줄임
    * CPU 사용량이 50%로 떨어지고 QPS와 스레드도 안정됨
* 한계에 도달한 Mysql 성능에 대해
  1. 일부러 부족한 하드웨어를 사용하지 않는 한, 한계에 도달하기 어렵다.
     * 애플리케이션은 모든 하드웨어를 동시에 완전히 활용하기 전에, 병목 현상을 일으킨다.
       * DB 성능의 한계가 아닌 하드웨어의 한계에 도달한 것이다.
  2. 높은 부하로 인해 MySQL이 느리게 응답한다고 해서 한계에 도달했다는 의미는 아니다.
     * 동시성이 증가하면 한계가 증가함, 느려진게 한계가 도달했다는건 아님

## 4-3 도요타와 페라리

* 두 자동차 브랜드 거의 똑같은 부품과 디자인을 사용한다.
* 하지만 페라리가 더 빠르다.
* 도요타는 고속 주행을 목표로 설계되지 않았고, 페라리는 모든 부분이 고속 주행을 목표로 설계되었다.
* MySQL의 성능을 높이기 위해 같은 관점으로 데이터 접근패턴을 설계할 수 있다.

## 4-4 데이터 접근 패턴

* 애플리케이션이 MySQL을 사용하여 DB에 접근하는 방법이다.
* 접근 패턴에 대한 3가지 세부 정보
    1. 접근 패턴은 개별적으로 수정해야 한다.
    2. 쿼리가 초점이 아니다.
       1. 쿼리는 구현이다. 인터페이스에 집중해야 한다.
          1. ex) 특정 접근 패턴은 MySQL 보다 key-value 스토리지가 적합
    3. 접근 패턴은 이름과 기술적인 특성 목록으로 구성된다.
       1. 이름 : 접근 패턴을 다른 엔지니어와 소통하는데 사용
       2. 기술적인 특성 목록 : 데이터 스토리지에 따라 접근 방법이 다름 (MySQL vs key-value)

### 읽기/쓰기

* SELECT : 명확한 읽기 접근
* INSERT..SELECT : 읽기와 쓰기 접근
* UPDATE, DELETE : WHERE 절이 있어서 읽기와 쓰기 접근 가능
* INSERT, UPDATE, DELETE : 쓰기 접근 (DELETE 도 쓰기 접근, 내부적으로 다른 쓰기)
* 모든 읽기는 같고 모든 쓰기는 같다.
* 읽기 확장은 offload 하여 수행함 (4장 5절에서 다룸)
* 쓰기 확장은 샤딩으로 확장 (5장에서 다룸)

### 처리량

* 처리량 (QPS) 는 성능이 아니다.
  * 1QPS 만으로 엄청난 피해를 줄 수 있다.
    * ex) 테이블 스캔을 수행하고 모든 행을 잠구는 SELECT...FOR UPDATE
* 매우 높은 QPS 는 해결해야 하는 문제 (QPS는 낮을수록 좋다)

### 데이터 수명

* 데이터 수명은 시간이 아니라 접근 순서에 상대적
  * 10분동안 백만개의 행 삽입
  * 첫번째 행은 10분밖에 안지난건데 가장 오래된 행이 됨
  * 첫번째 행을 갱신하면 가장 최신 행이 됨
* 이 특성은 작업 세트에 영향을 미치기에 중요함
  * MySQL은 될 수 있는 한 많은 데이터를 메모리에 보관함
  * 데이터에 접근하지 않으면 오래되어 결국 메모리에서 제거됨
* 오래된 데이터를 자주 접근하는것도 문제가 된다.
  * 기본 개념
    * 데이터는 여유 페이지 (메모리 내) 에 적재됨
    * 사용할 수 있는 여유 페이지가 있을때는 정상
    * 문제는 스토리지에서 데이터를 읽는 것은 속도가 느리다는 것
    * 비정상적으로 여유페이지가 하나도 없다면 더 문제가 된다.
  * 설명
    * MYSQL은 가장 최근 사용한 (LRU) 목록에서 추적하여 오래된 페이지를 제거한다.
    * 오래된 페이지가 dirty (데이터 변경 사항이 디스크에 유지되지 않는 경우) 일 때 MySQL 은 이를 제거할때 flush 한다.
      * flush 는 속도가 느리다.
    * 스토리지에서 데이터를 읽는 속도가 느리다.
    * 즉 오래된 데이터를 자주 가져오는것은 성능에 문제가 있다.

### 데이터 모델

* MySQL은 관계형 스토리지 이지만, 키-값 문서, 복잡한 분석, 그래프 등과 같은 다른 데이터모델도 지원
* 비관계형은 MySQL에 상당히 부적합
* MySQL은 키-값 으로도 잘 작동하지만 특별히 제작된 키-값 스토리지가 더 나음 (RocksDB)
* 유일한 옵션이 MySQL일때 접근 방식이 관계형
* 모범사례는 접근 방식에 이상적인 데이터 모델을 결정, 해당 데이터 모델로 구축된 데이터 스토리지를 사용하는 것

### 트랜잭션 격리

* 격리성은 ACID (원자성, 일관성, 격리성, 지속성) 중 하나이다.
* 모든 쿼리는 단일 SELECT 문을 포함하여 트랜잭션에서 실행된다.
* 따라서 접근이 필요하든 필요하지 않든 격리된다.
* 엔지니어가 사용하는 격리 수준의 범주
  * 없음
    * 비트랜잭션 스토리지 엔진에서도 올바르게 실행될때, 격리는 쓸모없는 오버헤드일 떄
  * 기본
    * 격리가 필요하지만 어떤 수준이 필요한지 모르는 경우
    * 기본 격리 수준인 REPEATABLE READ 으로 작동
  * 특정
    * 다른 트랜잭션과 동시에 실행되는 트랜잭션, 특정 격리 수준이 필요할 때
* 일반적인 범주는 기본을 사용한다.
* 그러나 '없음' 이나 '특정' 인것이 좋다.
  * 격리가 필요하지 않다면 트랜잭션 데이터 스토리지가 필요하지 않을 수 있다.
  * 격리가 필요하다면 격리 수준과 그 이유를 구체적으로 알 수 있다.
  * 필요한 격리 수준과 이유를 안다면 다른 MongoDB 같은 스토리지로 전환할 수 있다. 

### 읽기 일관성

* 강력한 일관성은 읽기가 가장 최신 값을 반환함을 의미
  * 강력한 일관성이 원본 MySQL 인스턴스의 유일한 옵션임
  * DynamoDB는 최종 일관성 읽기가 기본이고 강력한 일관성은 느리고 비쌈
* 최종 일관성은 읽기가 이전 값을 반환할 수 있지만, 나중에는 현재 값으로 반환함
  * MySQL 복제본은 1초 미만의 복제지연으로 차이가 발생하지만, 최종적 일관성임
* MySQL 세계에서는 기본적으로 모든 읽기가 강력하게 일관적
  * 그러나 읽기에 강력한 일관성이 요구되지 않는 경우도 많다.
  * 최종적 일관성이 허용되면 읽기 오프로드를 할 수 있다.

### 동시성

* 동시성이 제로라면 동시에 같은 데이터를 읽거나 쓰지 않는다는 것을 의미
  * ex) 고유한 행을 삽입하는 접근 패턴
* 동시성은 로우락이 얼마나 중요한지 나타냄
  * 응답시간은 lock wait timeout 이 발생하기 전까지만 허용됨
  * 이런 상황이 발생하면 동시성을 낮추거나 샤드 구성밖에 답이 없다
* 동시성은 읽기 접근에 캐시를 얼마나 적용할 수 있는지를 나타냄
  * 자주 변경되지 않을땐 캐시에 적합

### 행 접근

* 행에 접근하는 법
  * 포인트 접근 (point)
    * 알파벳을 사용하는 경우 포인트 접근은 임의의 단일 문자 (A)
  * 범위 접근 (range)
    * 순서대로 정렬된 문자 (ABC)
  * 임의 접근 (random)
    * 무작위 문자 (ASMR)
* 이 특성은 쓰기 접근에 중요하다
  * 갭 락
    * range, random 접근 쓰기는 갭 락으로 인해 로우락 경합을 악화시킴 (8장에서 설명)
  * 데드락
    * 데드락은 두 트랜잭션이 다른 트랜잭션에 필요한 로우 락을 보유하는 경우
    * MySQL이 감지하고 해제하지만, 성능을 떨어뜨림
* 행 접근은 샤딩 방법을 계획할 때도 중요, 효과적으로 샤딩하려면 접근 패턴이 단일 샤드를 사용해야 함
  * 포인트 접근은 하나의 행 하나의 샤드와 같은 샤딩에서 가장 잘 작동
  * 범위와 임의 접근은 너무 많은 샤드에 접근, 이점을 무효화 할 수 있음 (5장에서설명)

### 결과 세트 

* GROUP BY, ORDER BY, LIMIT 절이 있다?
  * 접근 방법이 어떻게 변경될지, 어떻게 실행될지에 대한 영향을 미침
  * 행을 그룹화 하거나 정렬하는 접근 방법을 최적화 해야 함
  * 다른 데이터 스토리지에서는 행에 그룹과 또는 정렬을 지원하지 않을 수 있음
